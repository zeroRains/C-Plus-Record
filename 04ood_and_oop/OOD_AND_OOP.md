
#  Composition(复合)

类里头有另外一个类，这种关系就叫做复合。黑色菱形加箭头，表示复合关系，有黑色菱形的一端表示容器，容器包含另外一个类的关系就叫做复合关系。

设计模式值——Adapter

在这个设计模式下设计的类中，他内部存在一个或多个其他功能比较强大的类的实例，我们当前设计的这个类大部分功能都可以利用内部这个类的一部分功能实现。

构造由内而外地进行构造——在一个类调用构造函数前，这个类的属性有其他类的实例，那么需要先调用内部这个类的默认构造函数创建出对应的属性。然后再继续进入到当前类中的构造函数，完成构造。

析构由外而内——在一个类调用析构函数时，如果这个类的属性有其他类的实例，那么在执行完自己的析构函数时，才会调用内部实例的析构函数。

# Delegation(委托)

在当前类中，有一个属性，他是另一个类的指针，那么这个关系就是委托关系。在UML的符号中可以使用空心菱形加箭头的方式表示委托关系，有空白菱形的一头表示容器。

Delegation中的指针实例创建时间和类的创建时间可能是不同步的。

该怎么设计不在主类中写出来，而是提供一个指针，然后如果要实现什么功能就用这个指针指向的类的实例进行实现。这种做法的名字叫做：point implementation。这个做法可以保护当前类的结构，当前类对应的属性任然是一个指针，但是这个指针指向的类，其内部定义可以不一样。也就是说内部属性对应的类变动，并不会影响当前类的运行。


# Inheritance（继承）

继承关系就是当前类在被继承的类的属性和方法的基础之上可以添加自己新的特性，同时可以重写被继承类内的方法。这个关系在UML中可以使用空心箭头加实线表示，其中空心箭头指向父类。

C++的继承有public private protected三种类型。父类的数据是被子类完全继承的。

继承最有价值的地方在于其与虚函数的搭配。

构造由内而外，析构由外而内。

虚函数的定义方式为在函数前面加上`virtual`关键字即可，相当于java中的抽象函数

现在要去创建未来的对象，则可以由未来的对象先创建，然后在这个类中提供一个克隆的方法，直接复制这个创建出来的对象。然后复制的对象需要存放到类的一个属性中，这个属性可以使用`prototype`这个类型进行定义

未来的类先创建一个自己这个类的实例，然后在这个未来的类的构造函数中，使用父类定义的`addPrototype`方法，将原型挂到父类上（将指针放到父类的属性中）。并在未来的类中都提供一个clone方法，主要就是实现new自己这个类的操作。













